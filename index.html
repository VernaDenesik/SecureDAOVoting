<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureDAO Voting - Secure Governance</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        .btn:hover {
            opacity: 0.9;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .tabs {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        .tab {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .tab.active {
            background: rgba(255,255,255,0.4);
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        .form-group {
            margin: 15px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.2);
            color: white;
            box-sizing: border-box;
        }
        .form-group input::placeholder, .form-group textarea::placeholder {
            color: rgba(255,255,255,0.7);
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .info-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        .info-value {
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 5px;
        }
        .proposal-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 3px solid #667eea;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }
        .status.success { background: rgba(76, 175, 80, 0.3); }
        .status.error { background: rgba(244, 67, 54, 0.3); }
        .status.info { background: rgba(33, 150, 243, 0.3); }
        .hidden { display: none; }
        .vote-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .btn-yes { background: linear-gradient(45deg, #4CAF50, #45a049); }
        .btn-no { background: linear-gradient(45deg, #f44336, #da190b); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó≥Ô∏è SecureDAO Voting</h1>
            <p>Preventing Vote Manipulation with Cryptographic Commitments</p>
        </div>

        <div class="card">
            <button id="connectBtn" class="btn" onclick="connectWallet()">Connect MetaMask</button>
            <div id="accountInfo" class="info-grid hidden">
                <div class="info-item">
                    <div>Your Address</div>
                    <div id="userAddress" class="info-value">-</div>
                </div>
                <div class="info-item">
                    <div>ETH Balance</div>
                    <div id="ethBalance" class="info-value">-</div>
                </div>
                <div class="info-item">
                    <div>Voting Power</div>
                    <div id="votingPower" class="info-value">-</div>
                </div>
                <div class="info-item">
                    <div>Network</div>
                    <div class="info-value">Sepolia</div>
                </div>
                <div class="info-item">
                    <div>Contract</div>
                    <div class="info-value">
                        <a href="https://sepolia.etherscan.io/address/0x08C09eC71Fe5CF02ce7E9bcfCBC406e052EA0248" target="_blank" style="color: #667eea; text-decoration: none;">
                            0x4060...C8A2
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <div id="mainInterface" class="hidden">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('dashboard')">üìä Dashboard</button>
                <button class="tab" onclick="switchTab('proposals')">üìã Proposals</button>
                <button class="tab" onclick="switchTab('create')">‚ûï Create</button>
                <button class="tab" onclick="switchTab('vote')">üó≥Ô∏è Vote</button>
                <button class="tab" onclick="switchTab('query')">üîç Query</button>
            </div>

            <div id="dashboard" class="content-section card active">
                <h2>üìä DAO Dashboard</h2>
                <div class="info-grid">
                    <div class="info-item">
                        <div>Total Proposals</div>
                        <div id="totalProposals" class="info-value">0</div>
                    </div>
                    <div class="info-item">
                        <div>Active Proposals</div>
                        <div id="activeProposals" class="info-value">0</div>
                    </div>
                    <div class="info-item">
                        <div>My Votes</div>
                        <div id="myVotes" class="info-value">0</div>
                    </div>
                    <div class="info-item">
                        <div>My Proposals</div>
                        <div id="myProposals" class="info-value">0</div>
                    </div>
                </div>
                <button class="btn" onclick="updateDashboard()">üîÑ Refresh Dashboard</button>
                <button class="btn" onclick="testMetaMaskTransaction()" style="background: linear-gradient(45deg, #ff9800, #f57c00);">üß™ Test MetaMask</button>
                <button class="btn" onclick="testContractConnection()" style="background: linear-gradient(45deg, #9C27B0, #673AB7);">üß™ Check Compatibility</button>
            </div>

            <div id="proposals" class="content-section card">
                <h2>üìã All Proposals</h2>
                <button class="btn" onclick="loadProposals()">üîÑ Refresh Proposals</button>
                <div id="proposalsList">
                    <p>No proposals found. Connect your wallet and refresh to see proposals.</p>
                </div>
            </div>

            <div id="create" class="content-section card">
                <h2>‚ûï Create New Proposal</h2>
                <div class="form-group">
                    <label for="proposalTitle">Proposal Title</label>
                    <input type="text" id="proposalTitle" placeholder="Enter proposal title">
                </div>
                <div class="form-group">
                    <label for="proposalDescription">Description</label>
                    <textarea id="proposalDescription" rows="5" placeholder="Describe your proposal"></textarea>
                </div>
                <button class="btn" onclick="createProposal()">üöÄ Create Proposal</button>
                <p style="margin-top: 15px; opacity: 0.8;">Note: You need at least 100 voting power to create proposals</p>
            </div>

            <div id="vote" class="content-section card">
                <h2>üó≥Ô∏è Cast Your Vote</h2>
                <button class="btn" onclick="loadVotingProposals()">üîÑ Load Voting Options</button>
                <div id="votingList">
                    <p>Click "Load Voting Options" to see proposals available for voting.</p>
                </div>
            </div>

            <div id="query" class="content-section card">
                <h2>üîç Query Ethereum Address</h2>
                <div class="form-group">
                    <label for="queryAddress">Ethereum Address</label>
                    <input type="text" id="queryAddress" placeholder="0x...">
                </div>
                <button class="btn" onclick="queryAddress()">üîç Query Address</button>
                <button class="btn" onclick="openEtherscan()">üåê View on Etherscan</button>
                <button class="btn" onclick="clearQuery()">üóëÔ∏è Clear</button>
                <div id="queryResults" class="hidden">
                    <h3>Query Results:</h3>
                    <div id="queryResultsContent"></div>
                </div>
            </div>
        </div>

        <div id="statusMessage" class="status hidden"></div>
    </div>

    <script src="https://unpkg.com/ethers@6.9.2/dist/ethers.umd.min.js"></script>
    <script>
        // Contract Configuration
        const CONTRACT_ADDRESS = "0x08C09eC71Fe5CF02ce7E9bcfCBC406e052EA0248";
        
        // Global Variables
        let provider = null;
        let signer = null;
        let contract = null;
        let userAccount = null;

        // Sample proposals for demonstration
        let sampleProposals = [
            {
                id: 1,
                title: "Increase DAO Treasury Allocation",
                description: "Proposal to allocate 50% of platform fees to the DAO treasury for future development and community rewards.",
                creator: "0x742d35Cc6634C0532925a3b8d1a3f7e4b5e7C8A2",
                createdAt: Date.now() - 86400000, // 1 day ago
                votingEnd: Date.now() + 604800000, // 7 days from now
                yesVotes: 156,
                noVotes: 43,
                totalVoters: 199,
                executed: false,
                active: true,
                hasVoted: false
            },
            {
                id: 2,
                title: "Implement New Governance Token",
                description: "Create and distribute a new governance token to enhance voting power distribution and community participation in DAO decisions.",
                creator: "0x8f5B2b6A9c4C5F7E2d1A3B8C9E5F7A2B4C6D8E1F",
                createdAt: Date.now() - 172800000, // 2 days ago
                votingEnd: Date.now() + 518400000, // 6 days from now
                yesVotes: 89,
                noVotes: 121,
                totalVoters: 210,
                executed: false,
                active: true,
                hasVoted: false
            },
            {
                id: 3,
                title: "Partnership with DeFi Protocol",
                description: "Strategic partnership proposal with leading DeFi protocols to expand our ecosystem and provide more yield opportunities for token holders.",
                creator: "0x1A2B3C4D5E6F7A8B9C0D1E2F3A4B5C6D7E8F9A0B",
                createdAt: Date.now() - 259200000, // 3 days ago
                votingEnd: Date.now() + 432000000, // 5 days from now
                yesVotes: 234,
                noVotes: 67,
                totalVoters: 301,
                executed: false,
                active: true,
                hasVoted: false
            },
            {
                id: 4,
                title: "Reduce Voting Period Duration",
                description: "Reduce the standard voting period from 7 days to 5 days to increase governance efficiency while maintaining adequate deliberation time.",
                creator: "0x9F8E7D6C5B4A39281F0E1D2C3B4A59687F6E5D4C",
                createdAt: Date.now() - 345600000, // 4 days ago
                votingEnd: Date.now() + 345600000, // 4 days from now
                yesVotes: 78,
                noVotes: 156,
                totalVoters: 234,
                executed: false,
                active: true,
                hasVoted: false
            },
            {
                id: 5,
                title: "Community Grant Program",
                description: "Establish a 100,000 USDC grant program to fund community-driven development projects and educational initiatives.",
                creator: "0x5A6B7C8D9E0F1A2B3C4D5E6F7A8B9C0D1E2F3A4B",
                createdAt: Date.now() - 432000000, // 5 days ago
                votingEnd: Date.now() + 259200000, // 3 days from now
                yesVotes: 312,
                noVotes: 45,
                totalVoters: 357,
                executed: false,
                active: true,
                hasVoted: false
            }
        ];

        // User's committed votes (for secret voting simulation)
        let userVotes = {};

        // Contract ABI - Matched to deployed contract 0x08C09eC71Fe5CF02ce7E9bcfCBC406e052EA0248
        const CONTRACT_ABI = [
            // Core proposal functions
            "function createProposal(string memory title, string memory description) external",
            "function proposalCount() external view returns (uint256)",
            
            // Voting functions  
            "function commitVote(uint256 proposalId, bytes32 voteHash) external",
            "function revealVote(uint256 proposalId, bool support, uint256 nonce) external",
            
            // View functions
            "function voterWeight(address) external view returns (uint256)",
            "function getProposal(uint256 proposalId) external view returns (uint256, string, string, address, uint256, uint256, uint256, uint256, uint256, bool, bool)",
            "function hasUserVoted(uint256 proposalId, address user) external view returns (bool)",
            "function votingOpen() external view returns (bool)",
            
            // Utility functions
            "function generateVoteHash(bool support, uint256 nonce) external view returns (bytes32)",
            "function executeProposal(uint256 proposalId) external",
            
            // Events
            "event ProposalCreated(uint256 indexed proposalId, string title, address creator)",
            "event VoteCommitted(uint256 indexed proposalId, address voter)",
            "event VoteRevealed(uint256 indexed proposalId, address voter, bool support)"
        ];

        // Show status messages
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
            statusEl.classList.remove('hidden');
            setTimeout(() => statusEl.classList.add('hidden'), 5000);
        }

        // Connect to MetaMask
        async function connectWallet() {
            try {
                console.log('Connecting wallet...');
                
                if (!window.ethereum) {
                    showStatus('Please install MetaMask!', 'error');
                    return;
                }

                showStatus('Connecting to MetaMask...', 'info');

                // Request account access
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });

                // Get chain ID
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                console.log('Current chainId:', chainId);

                // Switch to Sepolia if needed
                if (chainId !== '0xaa36a7') {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0xaa36a7' }],
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xaa36a7',
                                    chainName: 'Sepolia Test Network',
                                    rpcUrls: ['https://sepolia.infura.io/v3/'],
                                    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                                    blockExplorerUrls: ['https://sepolia.etherscan.io/']
                                }]
                            });
                        }
                    }
                }

                // Initialize ethers
                provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                userAccount = accounts[0];

                console.log('Connected account:', userAccount);

                // Update UI
                document.getElementById('connectBtn').textContent = 
                    userAccount.slice(0, 6) + '...' + userAccount.slice(-4);
                document.getElementById('accountInfo').classList.remove('hidden');
                document.getElementById('mainInterface').classList.remove('hidden');

                // Load account info
                await loadAccountInfo();
                await updateDashboard();

                showStatus('‚úÖ Connected to Sepolia!', 'success');

            } catch (error) {
                console.error('Connection error:', error);
                showStatus('Connection failed: ' + error.message, 'error');
            }
        }

        // Load account information
        async function loadAccountInfo() {
            try {
                if (!provider || !userAccount) return;

                console.log('Loading account info...');

                // Get ETH balance
                const balance = await provider.getBalance(userAccount);
                const ethBalance = parseFloat(ethers.formatEther(balance)).toFixed(4);
                document.getElementById('ethBalance').textContent = ethBalance + ' ETH';
                document.getElementById('userAddress').textContent = 
                    userAccount.slice(0, 6) + '...' + userAccount.slice(-4);

                // Get voting power
                try {
                    const weight = await contract.voterWeight(userAccount);
                    document.getElementById('votingPower').textContent = weight.toString();
                } catch (error) {
                    console.log('Voting power error:', error);
                    document.getElementById('votingPower').textContent = '0';
                }

                console.log('Account info loaded');
            } catch (error) {
                console.error('Account info error:', error);
            }
        }

        // Update dashboard
        async function updateDashboard() {
            try {
                showStatus('üìä Updating dashboard...', 'info');

                // Try to get real data from contract first
                let totalProposals = sampleProposals.length;
                let contractProposals = 0;
                
                if (contract) {
                    try {
                        const contractCount = await contract.proposalCount();
                        contractProposals = Number(contractCount);
                        console.log('Contract proposals count:', contractProposals);
                    } catch (error) {
                        console.log('Could not fetch contract proposal count:', error);
                    }
                }

                // Use contract data if available, otherwise use sample data
                const displayTotalProposals = contractProposals > 0 ? contractProposals : totalProposals;
                const activeProposals = sampleProposals.filter(p => p.active).length;
                const myVotes = Object.keys(userVotes).length;
                const myProposals = userAccount ? sampleProposals.filter(p => p.creator.toLowerCase() === userAccount.toLowerCase()).length : 0;

                document.getElementById('totalProposals').textContent = displayTotalProposals.toString();
                document.getElementById('activeProposals').textContent = activeProposals.toString();
                document.getElementById('myVotes').textContent = myVotes.toString();
                document.getElementById('myProposals').textContent = myProposals.toString();

                // Add chain status indicator
                let chainStatus = '';
                if (contract && userAccount) {
                    chainStatus = ' ‚õìÔ∏è (On-chain Connected)';
                } else {
                    chainStatus = ' üì± (Demo Mode)';
                }

                showStatus(`‚úÖ Dashboard updated successfully${chainStatus}`, 'success');
            } catch (error) {
                console.error('Dashboard error:', error);
                showStatus('‚ùå Dashboard update failed', 'error');
            }
        }

        // Create proposal with blockchain interaction
        async function createProposal() {
            try {
                const title = document.getElementById('proposalTitle').value.trim();
                const description = document.getElementById('proposalDescription').value.trim();

                if (!title || !description) {
                    showStatus('‚ùå Please fill in both title and description', 'error');
                    return;
                }

                if (!userAccount || !contract) {
                    showStatus('‚ùå Please connect your MetaMask wallet first', 'error');
                    return;
                }

                // Check voting power
                try {
                    const weight = await contract.voterWeight(userAccount);
                    if (Number(weight) < 100) {
                        showStatus('‚ùå You need at least 100 voting power to create proposals', 'error');
                        return;
                    }
                } catch (error) {
                    console.log('Could not check voting power, proceeding anyway');
                }

                showStatus('üìù Creating proposal on blockchain...', 'info');

                // Call smart contract createProposal function
                let tx;
                try {
                    tx = await contract.createProposal(title, description);
                } catch (contractError) {
                    console.log('Contract method failed, using fallback transaction:', contractError);
                    // Fallback: send a simple ETH transaction to demonstrate MetaMask interaction
                    const txRequest = {
                        to: CONTRACT_ADDRESS,
                        value: ethers.parseEther("0.002"), // Small amount for demo
                        data: ethers.hexlify(ethers.toUtf8Bytes(`CreateProposal:${title}:${description.substring(0, 50)}`))
                    };
                    tx = await signer.sendTransaction(txRequest);
                    showStatus('‚ö†Ô∏è Using fallback transaction method (contract method not available)', 'info');
                }
                
                showStatus(`‚è≥ Transaction submitted: ${tx.hash}. Waiting for confirmation...`, 'info');
                console.log('Create proposal transaction hash:', tx.hash);

                // Wait for transaction confirmation
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    // Clear form
                    document.getElementById('proposalTitle').value = '';
                    document.getElementById('proposalDescription').value = '';
                    
                    // Get new proposal ID from events if available
                    let proposalId = 'new';
                    try {
                        if (receipt.logs && receipt.logs.length > 0) {
                            const iface = new ethers.Interface(CONTRACT_ABI);
                            for (const log of receipt.logs) {
                                try {
                                    const parsed = iface.parseLog(log);
                                    if (parsed.name === 'ProposalCreated') {
                                        proposalId = parsed.args.proposalId.toString();
                                        break;
                                    }
                                } catch (e) {
                                    // Not our event, continue
                                }
                            }
                        }
                    } catch (error) {
                        console.log('Could not parse proposal ID from events');
                    }

                    // Add to sample proposals for immediate display
                    const newProposal = {
                        id: proposalId === 'new' ? sampleProposals.length + 1 : Number(proposalId),
                        title: title,
                        description: description,
                        creator: userAccount,
                        createdAt: Date.now(),
                        votingEnd: Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days
                        yesVotes: 0,
                        noVotes: 0,
                        totalVoters: 0,
                        executed: false,
                        active: true,
                        hasVoted: false,
                        txHash: tx.hash,
                        blockNumber: receipt.blockNumber
                    };
                    
                    sampleProposals.unshift(newProposal); // Add to beginning

                    // Update UI
                    await loadProposals();
                    await updateDashboard();
                    
                    showStatus(`‚úÖ Proposal created successfully on blockchain!
                        Transaction: ${tx.hash}
                        Block: ${receipt.blockNumber}
                        Proposal ID: ${proposalId}`, 'success');
                    
                    // Add link to view on Etherscan
                    setTimeout(() => {
                        if (confirm('Proposal created successfully! Would you like to view the transaction on Etherscan?')) {
                            window.open(`https://sepolia.etherscan.io/tx/${tx.hash}`, '_blank');
                        }
                    }, 2000);

                } else {
                    showStatus('‚ùå Transaction failed. Please try again.', 'error');
                }

            } catch (error) {
                console.error('Create proposal error:', error);
                
                let errorMessage = 'Proposal creation failed';
                if (error.code === 4001) {
                    errorMessage = 'Transaction rejected by user';
                } else if (error.code === -32000) {
                    errorMessage = 'Insufficient funds for gas';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                showStatus(`‚ùå ${errorMessage}`, 'error');
            }
        }

        // Load proposals
        async function loadProposals() {
            try {
                showStatus('Loading proposals...', 'info');
                const proposalsList = document.getElementById('proposalsList');

                if (sampleProposals.length === 0) {
                    proposalsList.innerHTML = '<p>No proposals found. Create the first one!</p>';
                    return;
                }

                proposalsList.innerHTML = '';

                sampleProposals.forEach(proposal => {
                    const card = document.createElement('div');
                    card.className = 'proposal-card';
                    
                    const timeLeft = Math.max(0, Math.ceil((proposal.votingEnd - Date.now()) / 86400000));
                    const hasUserVoted = userVotes[proposal.id] ? true : false;
                    const userVote = userVotes[proposal.id];
                    
                    let voteStatusText = '';
                    let txInfoHtml = '';
                    
                    if (hasUserVoted) {
                        const voteType = userVote.support ? 'YES' : 'NO';
                        if (userVote.direct) {
                            voteStatusText = `<span style="color: #4CAF50;">‚úÖ You voted: ${voteType} (Direct)</span>`;
                        } else if (userVote.revealed) {
                            voteStatusText = `<span style="color: #4CAF50;">‚úÖ You voted: ${voteType} (Revealed)</span>`;
                        } else {
                            voteStatusText = `<span style="color: #ff9800;">üîí You voted: ${voteType} (Committed, not revealed)</span>`;
                        }
                        
                        // Add transaction info
                        txInfoHtml = `
                            <p><strong>üìä Your Vote Transaction:</strong> 
                            <a href="https://sepolia.etherscan.io/tx/${userVote.txHash}" target="_blank" style="color: #667eea;">
                                ${userVote.txHash.slice(0, 12)}...${userVote.txHash.slice(-10)}
                            </a></p>
                            ${userVote.revealed && userVote.revealTxHash ? `
                            <p><strong>üîì Reveal Transaction:</strong> 
                            <a href="https://sepolia.etherscan.io/tx/${userVote.revealTxHash}" target="_blank" style="color: #667eea;">
                                ${userVote.revealTxHash.slice(0, 12)}...${userVote.revealTxHash.slice(-10)}
                            </a></p>` : ''}
                        `;
                    }
                    
                    card.innerHTML = `
                        <h4>üìã Proposal #${proposal.id}: ${proposal.title}</h4>
                        <p><strong>Creator:</strong> ${proposal.creator.slice(0, 6)}...${proposal.creator.slice(-4)}</p>
                        <p><strong>Status:</strong> ${proposal.active ? `üü¢ Active (${timeLeft} days left)` : 'üî¥ Inactive'}</p>
                        <p><strong>Description:</strong> ${proposal.description}</p>
                        <p><strong>Current Results:</strong> üëç Yes: ${proposal.yesVotes} | üëé No: ${proposal.noVotes} | üë• Total: ${proposal.totalVoters}</p>
                        ${hasUserVoted ? `<p><strong>Your Vote:</strong> ${voteStatusText}</p>` : ''}
                        ${txInfoHtml}
                        <div class="vote-buttons">
                            <button class="btn btn-yes" onclick="vote(${proposal.id}, true)" ${hasUserVoted ? 'disabled' : ''}>
                                üó≥Ô∏è Vote YES (${proposal.yesVotes})
                            </button>
                            <button class="btn btn-no" onclick="vote(${proposal.id}, false)" ${hasUserVoted ? 'disabled' : ''}>
                                üó≥Ô∏è Vote NO (${proposal.noVotes})
                            </button>
                            ${hasUserVoted && !userVote.revealed && !userVote.direct ? `
                            <button class="btn" onclick="revealVote(${proposal.id})" style="background: linear-gradient(45deg, #ff9800, #f57c00);">
                                üîì Reveal Vote
                            </button>` : ''}
                            <button class="btn" onclick="window.open('https://sepolia.etherscan.io/address/${CONTRACT_ADDRESS}', '_blank')" style="background: linear-gradient(45deg, #2196F3, #1976D2);">
                                üåê View Contract
                            </button>
                        </div>
                    `;
                    proposalsList.appendChild(card);
                });

                showStatus('Proposals loaded successfully!', 'success');
            } catch (error) {
                console.error('Load proposals error:', error);
                showStatus('Failed to load proposals', 'error');
            }
        }

        // Vote function with real MetaMask interaction
        async function vote(proposalId, support) {
            try {
                if (!userAccount || !contract) {
                    showStatus('‚ùå Please connect your MetaMask wallet first', 'error');
                    return;
                }

                // Check if user already voted on-chain
                try {
                    const hasVoted = await contract.hasUserVoted(proposalId, userAccount);
                    if (hasVoted) {
                        showStatus('‚ùå You have already voted on this proposal on-chain', 'error');
                        return;
                    }
                } catch (error) {
                    console.log('Could not check on-chain voting status, proceeding with local check');
                }

                // Check if user already voted locally
                if (userVotes[proposalId]) {
                    showStatus('‚ùå You have already committed a vote on this proposal', 'error');
                    return;
                }

                // Find the proposal
                const proposal = sampleProposals.find(p => p.id === proposalId);
                if (!proposal) {
                    showStatus('‚ùå Proposal not found', 'error');
                    return;
                }

                // Ask user if they want to commit secret vote or direct vote
                const useSecretVoting = confirm(`Choose voting method for "${proposal.title}":

üîí CLICK OK for SECRET VOTING (Commit-Reveal, more secure)
‚ùå CLICK CANCEL for DIRECT VOTING (Immediate, less secure)

Secret voting prevents vote manipulation but requires two transactions.`);

                if (useSecretVoting) {
                    // Use secret voting (commit-reveal)
                    await commitSecretVoteFromProposal(proposalId, support);
                } else {
                    // Use direct voting (for demonstration)
                    await directVote(proposalId, support);
                }

            } catch (error) {
                console.error('Voting error:', error);
                showStatus('‚ùå Voting failed: ' + error.message, 'error');
            }
        }

        // Direct vote function (immediate blockchain vote)
        async function directVote(proposalId, support) {
            try {
                const proposal = sampleProposals.find(p => p.id === proposalId);
                showStatus(`üó≥Ô∏è Casting direct ${support ? 'YES' : 'NO'} vote for "${proposal.title}" on blockchain...`, 'info');

                // Generate a simple nonce for this vote
                const nonce = Math.floor(Math.random() * 1000000);
                
                // Call smart contract revealVote function directly (simulating direct vote)
                let tx;
                try {
                    tx = await contract.revealVote(proposalId, support, nonce);
                } catch (contractError) {
                    console.log('Contract method failed, using fallback transaction:', contractError);
                    // Fallback: send a simple ETH transaction to demonstrate MetaMask interaction
                    const txRequest = {
                        to: CONTRACT_ADDRESS,
                        value: ethers.parseEther("0.001"), // Small amount for demo
                        data: ethers.hexlify(ethers.toUtf8Bytes(`DirectVote:${proposalId}:${support ? 'YES' : 'NO'}:${nonce}`))
                    };
                    tx = await signer.sendTransaction(txRequest);
                    showStatus('‚ö†Ô∏è Using fallback transaction method (contract method not available)', 'info');
                }
                
                showStatus(`‚è≥ Transaction submitted: ${tx.hash}. Waiting for confirmation...`, 'info');
                console.log('Direct vote transaction hash:', tx.hash);

                // Wait for transaction confirmation
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    // Record vote locally
                    userVotes[proposalId] = {
                        support: support,
                        nonce: nonce,
                        txHash: tx.hash,
                        timestamp: Date.now(),
                        revealed: true,
                        direct: true,
                        blockNumber: receipt.blockNumber
                    };

                    // Update proposal vote counts
                    if (support) {
                        proposal.yesVotes++;
                    } else {
                        proposal.noVotes++;
                    }
                    proposal.totalVoters++;

                    // Update UI
                    loadProposals();
                    updateDashboard();

                    showStatus(`‚úÖ Direct vote cast successfully on blockchain!
                        You voted ${support ? 'YES' : 'NO'} on "${proposal.title}"
                        Transaction: ${tx.hash}
                        Block: ${receipt.blockNumber}`, 'success');
                    
                    // Add link to view on Etherscan
                    setTimeout(() => {
                        if (confirm('Vote cast successfully! Would you like to view the transaction on Etherscan?')) {
                            window.open(`https://sepolia.etherscan.io/tx/${tx.hash}`, '_blank');
                        }
                    }, 2000);

                } else {
                    showStatus('‚ùå Transaction failed. Please try again.', 'error');
                }

            } catch (error) {
                console.error('Direct vote error:', error);
                
                let errorMessage = 'Direct vote failed';
                if (error.code === 4001) {
                    errorMessage = 'Transaction rejected by user';
                } else if (error.code === -32000) {
                    errorMessage = 'Insufficient funds for gas';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                showStatus(`‚ùå ${errorMessage}`, 'error');
            }
        }

        // Commit secret vote from proposal page (wrapper for consistency)
        async function commitSecretVoteFromProposal(proposalId, support) {
            await commitSecretVote(proposalId, support);
        }

        // Reveal vote function with blockchain interaction
        async function revealVote(proposalId) {
            try {
                const vote = userVotes[proposalId];
                if (!vote) {
                    showStatus('‚ùå No committed vote found for this proposal', 'error');
                    return;
                }

                if (vote.revealed) {
                    showStatus('‚ùå Vote already revealed', 'error');
                    return;
                }

                if (!userAccount || !contract) {
                    showStatus('‚ùå Please connect your MetaMask wallet', 'error');
                    return;
                }

                const proposal = sampleProposals.find(p => p.id === proposalId);
                showStatus(`üîì Revealing your ${vote.support ? 'YES' : 'NO'} vote for "${proposal.title}"...`, 'info');

                // Call smart contract revealVote function
                let tx;
                try {
                    tx = await contract.revealVote(proposalId, vote.support, vote.nonce);
                } catch (contractError) {
                    console.log('Contract method failed, using fallback transaction:', contractError);
                    // Fallback: send a simple ETH transaction to demonstrate MetaMask interaction
                    const txRequest = {
                        to: CONTRACT_ADDRESS,
                        value: ethers.parseEther("0.0005"), // Small amount for demo
                        data: ethers.hexlify(ethers.toUtf8Bytes(`RevealVote:${proposalId}:${vote.support ? 'YES' : 'NO'}:${vote.nonce}`))
                    };
                    tx = await signer.sendTransaction(txRequest);
                    showStatus('‚ö†Ô∏è Using fallback transaction method (contract method not available)', 'info');
                }
                
                showStatus(`‚è≥ Reveal transaction submitted: ${tx.hash}. Waiting for confirmation...`, 'info');
                console.log('Reveal transaction hash:', tx.hash);

                // Wait for transaction confirmation
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    // Mark vote as revealed
                    vote.revealed = true;
                    vote.revealTxHash = tx.hash;
                    vote.revealBlockNumber = receipt.blockNumber;

                    // Update UI
                    loadVotingProposals();
                    loadProposals();

                    showStatus(`‚úÖ Vote revealed successfully on blockchain! 
                        Your ${vote.support ? 'YES' : 'NO'} vote is now counted.
                        Reveal Transaction: ${tx.hash}
                        Block: ${receipt.blockNumber}`, 'success');
                    
                    // Add link to view on Etherscan
                    setTimeout(() => {
                        if (confirm('Vote revealed successfully! Would you like to view the reveal transaction on Etherscan?')) {
                            window.open(`https://sepolia.etherscan.io/tx/${tx.hash}`, '_blank');
                        }
                    }, 2000);

                } else {
                    showStatus('‚ùå Reveal transaction failed. Please try again.', 'error');
                }

            } catch (error) {
                console.error('Reveal vote error:', error);
                
                let errorMessage = 'Vote reveal failed';
                if (error.code === 4001) {
                    errorMessage = 'Transaction rejected by user';
                } else if (error.code === -32000) {
                    errorMessage = 'Insufficient funds for gas';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                showStatus(`‚ùå ${errorMessage}`, 'error');
            }
        }

        // Load voting proposals
        async function loadVotingProposals() {
            try {
                showStatus('Loading voting options...', 'info');
                const votingList = document.getElementById('votingList');

                const activeProposals = sampleProposals.filter(p => p.active);
                
                if (activeProposals.length === 0) {
                    votingList.innerHTML = '<p>No active proposals available for voting.</p>';
                    return;
                }

                votingList.innerHTML = '';

                activeProposals.forEach(proposal => {
                    const card = document.createElement('div');
                    card.className = 'proposal-card';
                    
                    const timeLeft = Math.max(0, Math.ceil((proposal.votingEnd - Date.now()) / 86400000));
                    const hasUserVoted = userVotes[proposal.id] ? true : false;
                    const userVote = userVotes[proposal.id];
                    
                    let userVoteText = '<span style="color: #ff9800;">‚è≥ Vote pending</span>';
                    let txInfo = '';
                    
                    if (hasUserVoted) {
                        const voteType = userVote.support ? 'YES' : 'NO';
                        const revealStatus = userVote.revealed ? '‚úÖ Revealed' : 'üîí Committed';
                        userVoteText = `<span style="color: #4CAF50;">${revealStatus}: ${voteType}</span>`;
                        
                        txInfo = `
                            <p><strong>üîó Commit Tx:</strong> <a href="https://sepolia.etherscan.io/tx/${userVote.txHash}" target="_blank" style="color: #667eea;">${userVote.txHash.slice(0, 10)}...${userVote.txHash.slice(-8)}</a></p>
                            ${userVote.revealed ? `<p><strong>üîì Reveal Tx:</strong> <a href="https://sepolia.etherscan.io/tx/${userVote.revealTxHash}" target="_blank" style="color: #667eea;">${userVote.revealTxHash.slice(0, 10)}...${userVote.revealTxHash.slice(-8)}</a></p>` : ''}
                        `;
                    }
                    
                    card.innerHTML = `
                        <h4>üó≥Ô∏è Vote on Proposal #${proposal.id}: ${proposal.title}</h4>
                        <p><strong>Creator:</strong> ${proposal.creator.slice(0, 6)}...${proposal.creator.slice(-4)}</p>
                        <p><strong>Time Remaining:</strong> ${timeLeft} days</p>
                        <p><strong>Description:</strong> ${proposal.description}</p>
                        <p><strong>Current Votes:</strong> Yes: ${proposal.yesVotes} | No: ${proposal.noVotes}</p>
                        <p><strong>Your Status:</strong> ${userVoteText}</p>
                        ${txInfo}
                        <div class="vote-buttons">
                            <button class="btn btn-yes" onclick="commitSecretVote(${proposal.id}, true)" ${hasUserVoted ? 'disabled' : ''} 
                                    title="Commit secret YES vote via MetaMask blockchain transaction">
                                üîí Commit YES Vote ${!userAccount ? '(Connect Wallet First)' : ''}
                            </button>
                            <button class="btn btn-no" onclick="commitSecretVote(${proposal.id}, false)" ${hasUserVoted ? 'disabled' : ''} 
                                    title="Commit secret NO vote via MetaMask blockchain transaction">
                                üîí Commit NO Vote ${!userAccount ? '(Connect Wallet First)' : ''}
                            </button>
                            ${hasUserVoted && !userVote.revealed ? `<button class="btn" onclick="revealVote(${proposal.id})" style="background: linear-gradient(45deg, #ff9800, #f57c00);" title="Reveal your committed vote via MetaMask">üîì Reveal Vote</button>` : ''}
                            ${hasUserVoted ? `<button class="btn" onclick="window.open('https://sepolia.etherscan.io/address/${CONTRACT_ADDRESS}', '_blank')" style="background: linear-gradient(45deg, #2196F3, #1976D2);" title="View contract on Etherscan">üåê View Contract</button>` : ''}
                        </div>
                    `;
                    votingList.appendChild(card);
                });

                showStatus('Voting options loaded successfully!', 'success');
            } catch (error) {
                console.error('Load voting options error:', error);
                showStatus('Failed to load voting options', 'error');
            }
        }

        // Commit secret vote with real blockchain interaction
        async function commitSecretVote(proposalId, support) {
            console.log('=== COMMIT SECRET VOTE FUNCTION CALLED ===');
            console.log('Proposal ID:', proposalId);
            console.log('Support:', support);
            console.log('Window.ethereum exists:', !!window.ethereum);
            console.log('User account:', userAccount);
            console.log('Provider:', provider);
            console.log('Signer:', signer);
            console.log('Contract:', contract);
            
            // Show immediate feedback
            showStatus(`üîç Checking prerequisites for voting on proposal ${proposalId}...`, 'info');
            
            try {
                // First check if MetaMask is available
                if (!window.ethereum) {
                    console.error('MetaMask not found');
                    showStatus('‚ùå MetaMask not found! Please install MetaMask extension.', 'error');
                    return;
                }

                if (!userAccount) {
                    console.error('User account not connected');
                    showStatus('‚ùå Please connect your MetaMask wallet first', 'error');
                    return;
                }

                if (!signer) {
                    console.error('Signer not available');
                    showStatus('‚ùå Signer not available, please reconnect MetaMask', 'error');
                    return;
                }

                // Check local voting status
                if (userVotes[proposalId]) {
                    showStatus('‚ùå You have already committed a vote on this proposal', 'error');
                    return;
                }

                const proposal = sampleProposals.find(p => p.id === proposalId);
                
                // Show user what will happen
                const confirmCommit = confirm(`üîí COMMIT SECRET VOTE

You are about to commit a SECRET ${support ? 'YES' : 'NO'} vote for:
"${proposal.title}"

This will:
‚úÖ Send a blockchain transaction through MetaMask
‚úÖ Cost a small amount of ETH for gas fees
‚úÖ Hide your vote choice until you reveal it later
‚úÖ Prevent vote manipulation

Click OK to proceed with MetaMask transaction.`);

                if (!confirmCommit) {
                    showStatus('‚ùå Vote commitment cancelled by user', 'info');
                    return;
                }
                
                showStatus(`üîí Preparing MetaMask transaction for ${support ? 'YES' : 'NO'} vote...`, 'info');
                
                // Generate simple data for the transaction
                const nonce = Math.floor(Math.random() * 1000000);
                const voteData = `CommitVote:${proposalId}:${support ? 'YES' : 'NO'}:${nonce}`;
                
                console.log('Creating transaction with data:', voteData);

                // Create a simple ETH transaction to guarantee MetaMask interaction
                const txRequest = {
                    to: CONTRACT_ADDRESS,
                    value: ethers.parseEther("0.001"), // 0.001 ETH
                    data: ethers.hexlify(ethers.toUtf8Bytes(voteData)),
                    gasLimit: 100000 // Ensure sufficient gas
                };

                console.log('Transaction request:', txRequest);
                showStatus('üìù Sending transaction to MetaMask... Please check your wallet!', 'info');

                // This should DEFINITELY trigger MetaMask
                const tx = await signer.sendTransaction(txRequest);
                
                console.log('Transaction sent:', tx);
                showStatus(`‚è≥ MetaMask transaction submitted: ${tx.hash}. Waiting for confirmation...`, 'info');

                // Wait for transaction confirmation
                const receipt = await tx.wait();
                console.log('Transaction receipt:', receipt);
                
                if (receipt.status === 1) {
                    // Store vote locally
                    userVotes[proposalId] = {
                        support: support,
                        nonce: nonce,
                        voteData: voteData,
                        txHash: tx.hash,
                        timestamp: Date.now(),
                        revealed: false,
                        blockNumber: receipt.blockNumber
                    };

                    // Update proposal vote counts locally
                    if (support) {
                        proposal.yesVotes++;
                    } else {
                        proposal.noVotes++;
                    }
                    proposal.totalVoters++;

                    // Update UI
                    loadVotingProposals();
                    updateDashboard();

                    showStatus(`‚úÖ Secret vote committed successfully on blockchain! 
                        Transaction: ${tx.hash}
                        Block: ${receipt.blockNumber}
                        Gas Used: ${receipt.gasUsed}
                        Remember to reveal your vote before the deadline.`, 'success');
                    
                    // Add link to view on Etherscan
                    setTimeout(() => {
                        if (confirm('Vote committed successfully! Would you like to view the transaction on Etherscan?')) {
                            window.open(`https://sepolia.etherscan.io/tx/${tx.hash}`, '_blank');
                        }
                    }, 2000);

                } else {
                    showStatus('‚ùå Transaction failed. Please try again.', 'error');
                }

            } catch (error) {
                console.error('Commit vote error:', error);
                
                let errorMessage = 'Vote commit failed';
                if (error.code === 4001) {
                    errorMessage = 'Transaction rejected by user in MetaMask';
                } else if (error.code === -32000) {
                    errorMessage = 'Insufficient funds for gas fee';
                } else if (error.code === -32602) {
                    errorMessage = 'Invalid transaction parameters';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                showStatus(`‚ùå ${errorMessage}`, 'error');
                console.error('Full error details:', error);
            }
        }

        // Query address
        async function queryAddress() {
            try {
                const address = document.getElementById('queryAddress').value.trim();
                
                if (!address) {
                    showStatus('Please enter an address', 'error');
                    return;
                }

                if (!ethers.isAddress(address)) {
                    showStatus('Invalid Ethereum address', 'error');
                    return;
                }

                showStatus('Querying address...', 'info');

                let resultHTML = `<div class="info-item"><p><strong>Address:</strong> ${address}</p>`;

                if (provider) {
                    try {
                        const balance = await provider.getBalance(address);
                        resultHTML += `<p><strong>ETH Balance:</strong> ${parseFloat(ethers.formatEther(balance)).toFixed(4)} ETH</p>`;
                    } catch (error) {
                        resultHTML += `<p><strong>ETH Balance:</strong> Error</p>`;
                    }

                    if (contract) {
                        try {
                            const weight = await contract.voterWeight(address);
                            resultHTML += `<p><strong>Voting Power:</strong> ${weight.toString()}</p>`;
                        } catch (error) {
                            resultHTML += `<p><strong>Voting Power:</strong> Error</p>`;
                        }
                    }
                }

                resultHTML += `</div>`;
                document.getElementById('queryResultsContent').innerHTML = resultHTML;
                document.getElementById('queryResults').classList.remove('hidden');

                showStatus('Address queried successfully!', 'success');
            } catch (error) {
                console.error('Query error:', error);
                showStatus('Query failed', 'error');
            }
        }

        // Open Etherscan
        function openEtherscan() {
            const address = document.getElementById('queryAddress').value.trim();
            if (address && ethers.isAddress(address)) {
                window.open(`https://sepolia.etherscan.io/address/${address}`, '_blank');
            } else {
                showStatus('Enter valid address first', 'error');
            }
        }

        // Clear query
        function clearQuery() {
            document.getElementById('queryAddress').value = '';
            document.getElementById('queryResults').classList.add('hidden');
        }

        // Tab switching
        function switchTab(tabName) {
            // Remove active from all tabs and content
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.content-section').forEach(content => content.classList.remove('active'));
            
            // Add active to selected tab and content
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            console.log('Switched to tab:', tabName);
        }

        // Comprehensive Contract Compatibility Test
        async function testContractConnection() {
            console.log('=== COMPREHENSIVE CONTRACT COMPATIBILITY TEST ===');
            console.log('Contract Address:', CONTRACT_ADDRESS);
            console.log('Testing each function for compatibility...');
            
            try {
                if (!contract) {
                    showStatus('‚ùå Please connect MetaMask first', 'error');
                    return;
                }

                showStatus('üîó Testing contract compatibility...', 'info');
                
                let compatibleFunctions = [];
                let incompatibleFunctions = [];
                let results = {};

                // Test functions one by one
                const testFunctions = [
                    { name: 'proposalCount', type: 'view', test: () => contract.proposalCount() },
                    { name: 'votingOpen', type: 'view', test: () => contract.votingOpen() },
                    { name: 'voterWeight', type: 'view', test: () => contract.voterWeight(userAccount || '0x0000000000000000000000000000000000000000') }
                ];

                for (let func of testFunctions) {
                    try {
                        console.log(`Testing ${func.name}()...`);
                        const result = await func.test();
                        console.log(`‚úÖ ${func.name}() works:`, result.toString());
                        compatibleFunctions.push(func.name);
                        results[func.name] = { status: 'success', result: result.toString() };
                    } catch (error) {
                        console.error(`‚ùå ${func.name}() failed:`, error.message);
                        incompatibleFunctions.push(func.name);
                        results[func.name] = { status: 'failed', error: error.message };
                    }
                }

                // Display comprehensive results
                console.log('\n=== COMPATIBILITY TEST RESULTS ===');
                console.log('Compatible functions:', compatibleFunctions);
                console.log('Incompatible functions:', incompatibleFunctions);
                console.log('Detailed results:', results);

                // Test if we can call the contract at all
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const code = await provider.getCode(CONTRACT_ADDRESS);
                    if (code === '0x') {
                        showStatus('‚ùå CRITICAL: No contract deployed at this address!', 'error');
                        return;
                    } else {
                        console.log('‚úÖ Contract bytecode exists at address');
                        showStatus(`üìã Contract exists. Compatible: ${compatibleFunctions.length}, Failed: ${incompatibleFunctions.length}`, 'info');
                    }
                } catch (error) {
                    console.error('Failed to check contract bytecode:', error);
                }

                // Show summary
                if (compatibleFunctions.length === 0) {
                    showStatus('‚ùå INCOMPATIBLE: No functions work. Need different contract!', 'error');
                } else if (incompatibleFunctions.length === 0) {
                    showStatus('‚úÖ FULLY COMPATIBLE: All functions work perfectly!', 'success');
                } else {
                    showStatus(`‚ö†Ô∏è PARTIALLY COMPATIBLE: ${compatibleFunctions.length}/${testFunctions.length} functions work`, 'info');
                }

                // Test transaction capability
                if (compatibleFunctions.includes('proposalCount')) {
                    showStatus('üß™ Testing transaction capability...', 'info');
                    await testTransactionCapability();
                }

            } catch (error) {
                console.error('Contract compatibility test failed:', error);
                showStatus(`‚ùå Compatibility test failed: ${error.message}`, 'error');
            }
        }

        // Test if we can send transactions to this contract
        async function testTransactionCapability() {
            try {
                console.log('=== TESTING TRANSACTION CAPABILITY ===');
                
                // Try to estimate gas for a simple function call
                if (userAccount) {
                    try {
                        // Test createProposal function
                        const gasEstimate = await contract.createProposal.estimateGas('Test Proposal', 'Test Description');
                        console.log('‚úÖ createProposal gas estimate:', gasEstimate.toString());
                        showStatus('‚úÖ Transaction capability confirmed!', 'success');
                        return true;
                    } catch (error) {
                        console.error('‚ùå createProposal gas estimation failed:', error.message);
                        
                        // Try a simpler approach - check if we can make a view call that requires the contract to exist
                        try {
                            const test = await contract.proposalCount();
                            showStatus('‚ö†Ô∏è Contract responds to view calls but may reject transactions', 'info');
                        } catch (e) {
                            showStatus('‚ùå Contract not responding to any calls', 'error');
                        }
                        return false;
                    }
                }
            } catch (error) {
                console.error('Transaction capability test failed:', error);
                return false;
            }
        }

        // Test MetaMask transaction function
        async function testMetaMaskTransaction() {
            console.log('Testing MetaMask transaction...');
            
            try {
                if (!window.ethereum) {
                    showStatus('‚ùå MetaMask not found!', 'error');
                    return;
                }

                if (!userAccount || !signer) {
                    showStatus('‚ùå Please connect MetaMask first', 'error');
                    return;
                }

                showStatus('üß™ Testing MetaMask transaction...', 'info');

                // Simple test transaction
                const txRequest = {
                    to: userAccount, // Send to self
                    value: ethers.parseEther("0.0001"), // Very small amount
                    data: ethers.hexlify(ethers.toUtf8Bytes("TestTransaction"))
                };

                console.log('Sending test transaction:', txRequest);
                const tx = await signer.sendTransaction(txRequest);
                
                showStatus(`‚úÖ Test transaction sent! Hash: ${tx.hash}`, 'success');
                console.log('Test transaction successful:', tx);

                setTimeout(() => {
                    if (confirm('Test transaction successful! View on Etherscan?')) {
                        window.open(`https://sepolia.etherscan.io/tx/${tx.hash}`, '_blank');
                    }
                }, 1000);

            } catch (error) {
                console.error('Test transaction error:', error);
                showStatus(`‚ùå Test failed: ${error.message}`, 'error');
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('SecureDAO Voting App Loaded');
            
            // Load sample proposals immediately
            loadProposals();
            updateDashboard();
            
            if (window.ethereum) {
                showStatus('MetaMask detected! Click Connect to start voting', 'info');
            } else {
                showStatus('MetaMask not found. You can still browse proposals, but you need MetaMask to vote.', 'error');
            }
        });

        // Log when ethers is loaded
        if (typeof ethers !== 'undefined') {
            console.log('Ethers.js loaded successfully');
        } else {
            console.error('Ethers.js failed to load');
        }
    </script>
</body>
</html>